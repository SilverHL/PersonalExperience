管道　

先是不具名管道　主要用于有亲缘关系的进程　
0是读端 1是写端  也就是说 从进程向管道write的端口是pipe[1] 进程read的端口是pipe[0] 
但是读端对写端是有依赖的 栗子见./test/pipe/readRelay.cpp
将子进程的读写端都关闭 然后将父进程的读端关闭 父进程向管道write的时候 捕捉到了SIGPIPE信号

管道的写入并不是原子性的

管道的局限性 
    仅限于有亲缘关系的进程 单向数据流 
    缓冲区是有限的 而且字节无格式 

然后是有名管道 有名管道可以提供无亲缘关系之间的进程通信，FIFO是严格的先进先出 
不支持lseek等文件定位操作

int mkfifo(const char* pathname, mode_t mode);

有名管道 第一个参数如果已经存在 会返回EEXIST错误 一般的调用代码会先检查是否返回该错误 
如果会返回的话 那就直接打开该fifo

fifo的打开规则：
    fifo存在阻塞打开 一个进程是为了读打开fifo时 必须有另一个进程为了写打开fifo 否则如果打开的时候
    设置了阻塞 那就会阻塞至写打开fifo的进程

    而一个进程是为了写打开fifo时，同样的情况 不同的是 如果没有进程为了读打开fifo 当前进程也
    没有设置阻塞 那么会返回ENXIO错误

fifo的读写规则 
    一个进程为写打开fifo 当前fifo如果没有数据 若设置了阻塞标志 那么就会一直阻塞到有数据
    没有设置就会返回EAGAIN错误 
    而对于设置了阻塞的读进程 如果阻塞 说明当前fifo要么没有数据 要么就是有别的进程在读这些数据
    读打开的阻塞只对本进程的第一个读操作施加作用  如果本进程内有多个读操作 在第一个读操作
    被唤醒并完成操作后 后面的读操作将不再被阻塞 只会返回0或是目标字节数 

向fifo写入数据时 
    写入的数据量不大于PIPE_BUF 时 ，linux将保证写入的原子性，此时管道空闲区不足以容纳要写入的
    字节数则进入睡眠，知道缓冲区能够容纳要写入的字节时，才开始一次性写操作

    写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性
